.TH "C:/Users/Sig/Dropbox/MacrosLib/src/toadd.h" 3 "Mon Jan 6 2020" "Version 0.1.0-a1" "MacrosLib" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/Users/Sig/Dropbox/MacrosLib/src/toadd.h \- The main macros of the library\&.  

.SH SYNOPSIS
.br
.PP
\fC#include 'xmacro\&.h'\fP
.br
\fC#include 'perfcounters_ctr\&.h'\fP
.br
\fC#include 'perfcounter_ctr\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBushort\fP   unsigned short"
.br
.ti -1c
.RI "#define \fBuint\fP   unsigned int"
.br
.ti -1c
.RI "#define \fBuchar\fP   unsigned char"
.br
.ti -1c
.RI "#define \fBloop0i\fP(end_l)   for ( int i=0;i<end_l;++i )"
.br
.ti -1c
.RI "#define \fBloop0j\fP(end_l)   for ( int j=0;j<end_l;++j )"
.br
.ti -1c
.RI "#define \fBloopi\fP(start_l,  end_l)   for ( int i=start_l;i<end_l;++i )"
.br
.ti -1c
.RI "#define \fBloopj\fP(start_l,  end_l)   for ( int j=start_l;j<end_l;++j )"
.br
.ti -1c
.RI "#define \fBloopk\fP(start_l,  end_l)   for ( int k=start_l;k<end_l;++k )"
.br
.ti -1c
.RI "#define \fBloopl\fP(start_l,  end_l)   for ( int l=start_l;l<end_l;++l )"
.br
.ti -1c
.RI "#define \fBloopm\fP(start_l,  end_l)   for ( int m=start_l;m<end_l;++m )"
.br
.ti -1c
.RI "#define \fBloopn\fP(start_l,  end_l)   for ( int n=start_l;n<end_l;++n )"
.br
.ti -1c
.RI "#define \fBloop\fP(a_l,  start_l,  end_l)   for ( int a_l = start_l;a_l<end_l;++a_l )"
.br
.ti -1c
.RI "#define \fBloopij\fP(_sti,  _stj,  _eni,  _enj)   loopi(_sti,_eni)loopj (_stj,_enj)"
.br
.ti -1c
.RI "#define \fBloopijk\fP(_sti,  _stj,  _stk,  _eni,  _enj,  _enk)   loopi(_sti,_eni) loopj (_stj,_enj) loopk (_stk,_enk)"
.br
.ti -1c
.RI "#define \fBlooplmn\fP(_stl,  _stm,  _stn,  _enl,  _enm,  _enn)   loopl(_stl,_enl) loopm (_stm,_enm) loopn (_stn,_enn)"
.br
.ti -1c
.RI "#define \fBforeach\fP(var,  container)   for( auto var = (container)\&.begin(); var != (container)\&.end(); ++var)"
.br
.ti -1c
.RI "#define \fBf_min\fP   min"
.br
.ti -1c
.RI "#define \fBf_max\fP   max"
.br
.ti -1c
.RI "#define \fBmin\fP(a,  b)   (((a)<(b))?(a):(b))"
.br
.ti -1c
.RI "#define \fBmax\fP(a,  b)   (((a)>(b))?(a):(b))"
.br
.ti -1c
.RI "#define \fBclamp\fP(a_,  b_,  c_)   min(max(a_,b_),c_)"
.br
.ti -1c
.RI "#define \fBfrac\fP(a)   (a\-floor(a))"
.br
.ti -1c
.RI "#define \fBdot3\fP(a,  b)   (a\&.x*b\&.x+a\&.y*b\&.y+a\&.z*b\&.z)"
.br
.ti -1c
.RI "#define \fBcross3\fP(a,  b)   vec3f( a\&.y * b\&.z \- a\&.z * b\&.y, a\&.z * b\&.x \- a\&.x * b\&.z , a\&.x * b\&.y \- a\&.y * b\&.x )"
.br
.ti -1c
.RI "#define \fBlerp\fP(a_,  b_,  t_)   ( a_*(1\-t_) + b_*t_ )"
.br
.ti -1c
.RI "#define \fBvswap\fP(a,  b)   { auto c=a;a=b;b=c; }"
.br
.ti -1c
.RI "#define \fBerror_stop\fP(fmt, \&.\&.\&.)"
.br
.ti -1c
.RI "#define \fBENSURE_NOEXCEPT_STATEMENT\fP(stmt)"
.br
.ti -1c
.RI "#define \fBNOEXCEPT\fP   noexcept"
.br
.ti -1c
.RI "#define \fBENSURE_NOEXCEPT_EXPRESSION\fP(expr)"
.br
.ti -1c
.RI "#define \fBNOEXCEPT_CTCHECK_PUB_HPP_\fP"
.br
.ti -1c
.RI "#define \fBNOEXCEPT_CTCHECK_VERSION\fP   1000000"
.br
.ti -1c
.RI "#define \fBNOEXCEPT_CTCHECK_ENSURE_NOEXCEPT_STATEMENT\fP(stmt)"
.br
.ti -1c
.RI "#define \fBNOEXCEPT_CTCHECK_ENSURE_NOT_NOEXCEPT_STATEMENT\fP(stmt)"
.br
.ti -1c
.RI "#define \fBNOEXCEPT_CTCHECK_STATIC_ASSERT_NOEXCEPT\fP(expr)   static_assert(noexcept(expr), #expr ' is expected to be noexcept' )"
.br
.ti -1c
.RI "#define \fBNOEXCEPT_CTCHECK_STATIC_ASSERT_NOT_NOEXCEPT\fP(expr)   static_assert(!noexcept(expr), #expr ' is not expected to be noexcept' )"
.br
.ti -1c
.RI "#define \fBprefix_safeCall\fP(defaultValue,  objectPointer,  methodWithArguments)"
.br
.ti -1c
.RI "#define \fBprefix_safeCallVoid\fP(objectPointer,  methodWithArguments)"
.br
.ti -1c
.RI "#define \fBprefix_safeCallBaseExpression\fP(defaultValue,  objectPointer,  methodWithArguments)   ((ptr) ? ((ptr)\->methodWithArguments) : (defaultValue))"
.br
.ti -1c
.RI "#define \fBprefix_safeCall\fP(defaultValue,  objectPointer,  methodWithArguments)"
.br
.ti -1c
.RI "#define \fBprefix_safeCallVoid\fP(objectPointer,  methodWithArguments)"
.br
.ti -1c
.RI "#define \fBprefix_unused\fP(variable)   ((void)variable)"
.br
.ti -1c
.RI "#define \fBprefix_unused1\fP(variable1)   static_cast<void>(variable1)"
.br
.ti -1c
.RI "#define \fBprefix_unused2\fP(variable1,  variable2)   static_cast<void>(variable1), static_cast<void>(variable2)"
.br
.ti -1c
.RI "#define \fBprefix_unused3\fP(variable1,  variable2,  variable3)   static_cast<void>(variable1), static_cast<void>(variable2), static_cast<void>(variable3)"
.br
.ti -1c
.RI "#define \fBprefix_unused4\fP(variable1,  variable2,  variable3,  variable4)   static_cast<void>(variable1), static_cast<void>(variable2), static_cast<void>(variable3), static_cast<void>(variable4)"
.br
.ti -1c
.RI "#define \fBprefix_unused5\fP(variable1,  variable2,  variable3,  variable4,  variable5)   static_cast<void>(variable1), static_cast<void>(variable2), static_cast<void>(variable3), static_cast<void>(variable4), static_cast<void>(variable5)"
.br
.ti -1c
.RI "#define \fBunused2\fP(variable1,  variable2)   do {static_cast<void>(variable1); static_cast<void>(variable2);} while(false)"
.br
.ti -1c
.RI "#define \fBprefix_stringify\fP(something)   std::string(#something)"
.br
.ti -1c
.RI "#define \fBprefix_singleArgument\fP(\&.\&.\&.)   __VA_ARGS__"
.br
.ti -1c
.RI "#define \fBFOO\fP(type,  name)   type name"
.br
.ti -1c
.RI "#define \fBforever\fP()   for(;;)"
.br
.ti -1c
.RI "#define \fBever\fP   (;;)"
.br
.ti -1c
.RI "#define \fBPI\fP   3\&.14"
.br
.ti -1c
.RI "#define \fBSUM\fP(A,  B)   ((A)+(B))"
.br
.ti -1c
.RI "#define \fBC_MODE_START\fP   extern 'C' {"
.br
.ti -1c
.RI "#define \fBCONCAT\fP(a,  b)   a##b"
.br
.ti -1c
.RI "#define \fBZ\fP   ((X)+(Y))"
.br
.ti -1c
.RI "#define \fBFUN_CALL\fP   do { f(); } while(0)"
.br
.ti -1c
.RI "#define \fBTYPE_CHAR\fP   (char*)"
.br
.ti -1c
.RI "#define \fB__GNUG__\fP   (__GNUC__&&__cplusplus)"
.br
.ti -1c
.RI "#define \fBDIFF\fP(A,  B)   (MAX((A),(B))\-MIN((A),(B)))"
.br
.ti -1c
.RI "#define \fBTYPE_CHAR\fP   (char*)"
.br
.ti -1c
.RI "#define \fBARCHITECTURE\fP   32"
.br
.ti -1c
.RI "#define \fBCONCAT\fP(a,  b)   a##b"
.br
.ti -1c
.RI "#define \fBSLOPE\fP   (5\&.0 / 9\&.0)"
.br
.ti -1c
.RI "#define \fBCEL\fP(T)   SLOPE * (T \- THRESH)"
.br
.ti -1c
.RI "#define \fBTHRESH\fP   32\&.0"
.br
.ti -1c
.RI "#define \fBPI\fP   3\&.14"
.br
.ti -1c
.RI "#define \fBSEVEN\fP   3 + 4"
.br
.ti -1c
.RI "#define \fBFILENAME\fP   'header\&.h'"
.br
.ti -1c
.RI "#define \fBA\fP   X"
.br
.ti -1c
.RI "#define \fBR\fP   10"
.br
.RI "A wrapper around static_assert for checking that a statement is noexcept and execution of that statement\&. "
.ti -1c
.RI "#define \fBPI\fP   3\&.14"
.br
.ti -1c
.RI "#define \fBAREA_CIRCLE\fP   PI * \fBR\fP * \fBR\fP"
.br
.ti -1c
.RI "#define \fBPRINT\fP   printf"
.br
.ti -1c
.RI "#define \fBSUM\fP   a + b"
.br
.ti -1c
.RI "#define \fBINT_VEC\fP   vector<int>"
.br
.ti -1c
.RI "#define \fBUINT\fP   unsigned int"
.br
.ti -1c
.RI "#define \fBUINT_PTR\fP   UINT*"
.br
.ti -1c
.RI "#define \fBA\fP   T"
.br
.ti -1c
.RI "#define \fBMIN\fP(A,  B)   ((A) < (B) ? (A) : (B))"
.br
.ti -1c
.RI "#define \fBASSIGN\fP(A,  B)   { B = A; }"
.br
.ti -1c
.RI "#define \fBF\fP(A1, \&.\&.\&.,  An)   X"
.br
.ti -1c
.RI "#define \fBF\fP(A1, \&.\&.\&.,  An)   S"
.br
.ti -1c
.RI "#define \fBOP\fP(A,  B)   (X + MAX((A),(B))\-MIN((A),(B)))"
.br
.ti -1c
.RI "#define \fBAcc\fP(a,  b)   { a += f(b); }"
.br
.ti -1c
.RI "#define \fBA\fP(T1, \&.\&.\&.,  Tn)   X"
.br
.ti -1c
.RI "#define \fBPTR_TYPE\fP(T)   T*"
.br
.ti -1c
.RI "#define \fBValueType\fP(I)   typename value_type<I>::type;"
.br
.ti -1c
.RI "#define \fBS0\fP(X)   S[X]"
.br
.ti -1c
.RI "#define \fBTEMP_KEL\fP   273 + cel"
.br
.ti -1c
.RI "#define \fBTEMP_FAR\fP   cel * 9 / 5 + 32"
.br
.ti -1c
.RI "#define \fBPI\fP   3\&.14"
.br
.ti -1c
.RI "#define \fBXMACRO\fP(x)   x,"
.br
.ti -1c
.RI "#define \fBXMACRO\fP(x)   case xenum::x: os << 'xenum::' #x; break;"
.br
.ti -1c
.RI "#define \fBNV_PERFCOUNTER\fP(ctr)   ctr,"
.br
.ti -1c
.RI "#define \fBNV_PERFCOUNTER\fP(ctr)   { static_cast<int>(counter_enum::ctr), \&.\&.\&. },"
.br
.ti -1c
.RI "#define \fBNV_PERFCOUNTER\fP(ctr)   inline void ctr##_tick(size_t diff = 1) { /* Увеличение счетчика counter_enum::ctr */ }"
.br
.ti -1c
.RI "#define \fBNV_PERFCOUNTER\fP(ctr)   inline size_t ctr##_get() { /* Возврат значения счетчика counter_enum::ctr */ }"
.br
.ti -1c
.RI "#define \fBDEFINE_ENUM_MEMBER\fP(name)   name,"
.br
.ti -1c
.RI "#define \fBDEFINE_ENUM\fP(name,  list)"
.br
.ti -1c
.RI "#define \fBDEFINE_ENUM_CASE\fP(name)   case name: return #name;"
.br
.ti -1c
.RI "#define \fBDEFINE_ENUM_TO_STRING\fP(name,  list)"
.br
.ti -1c
.RI "#define \fBenum_test1\fP(handler)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBxenum\fP { \fBXMACRO\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &os, xenum enm)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "int \fBx\fP = 10"
.br
.in -1c
.SH "Detailed Description"
.PP 
The main macros of the library\&. 


.SH "Macro Definition Documentation"
.PP 
.SS "#define DEFINE_ENUM(name, list)"
\fBValue:\fP
.PP
.nf
enum name { \
    list(DEFINE_ENUM_MEMBER) \
    };
.fi
.SS "#define DEFINE_ENUM_TO_STRING(name, list)"
\fBValue:\fP
.PP
.nf
const char* name ## _tostring(name v) { \
        switch (v) { \
            list(DEFINE_ENUM_CASE) \
        } \
        return "?"; \
    }
.fi
.SS "#define ENSURE_NOEXCEPT_EXPRESSION(expr)"
\fBValue:\fP
.PP
.nf
([&]() noexcept -> decltype(auto) { \
     static_assert(noexcept(expr), #expr " is expected to be noexcept"); \
     return expr; \
  }())
.fi
.SS "#define ENSURE_NOEXCEPT_STATEMENT(stmt)"
\fBValue:\fP
.PP
.nf
do { \
      static_assert(noexcept(stmt), "this statement is expected to be noexcept: " #stmt); \
      stmt; \
   } while(false)
.fi
.SS "#define enum_test1(handler)"
\fBValue:\fP
.PP
.nf
handler(field1) \
    handler(field2) \
.fi
.SS "#define error_stop(fmt,  \&.\&.\&.)"
\fBValue:\fP
.PP
.nf
{\
    char text[10000];\
    sprintf(text,("" fmt "\n\nCallstack:\n%s [%s:%d]\n%s"),\
    ##__VA_ARGS__,__FUNCTION__,__FILE__,  __LINE__, "");\
    printf(text);\
    MessageBoxA(0,text,"Error",0);exit(0);\
    while(1);;\
};
.fi
.SS "#define NOEXCEPT_CTCHECK_ENSURE_NOEXCEPT_STATEMENT(stmt)"
\fBValue:\fP
.PP
.nf
do { \
        static_assert(noexcept(stmt), "this statement is expected to be noexcept: " #stmt); \
        stmt; \
    } while(false)
.fi
.SS "#define NOEXCEPT_CTCHECK_ENSURE_NOT_NOEXCEPT_STATEMENT(stmt)"
\fBValue:\fP
.PP
.nf
do { \
        static_assert(!noexcept(stmt), "this statement is not expected to be noexcept: " #stmt); \
        stmt; \
    } while(false)
.fi
.SS "#define prefix_safeCall(defaultValue, objectPointer, methodWithArguments)"
\fBValue:\fP
.PP
.nf
[&](auto&& ptr) -> decltype(auto)\
{\
    return ptr ? (ptr->methodWithArguments) : (defaultValue);\
}\
(objectPointer)
.fi
.SS "#define prefix_safeCall(defaultValue, objectPointer, methodWithArguments)"
\fBValue:\fP
.PP
.nf
[&](decltype((objectPointer))&& ptr)\
    -> decltype(prefix_safeCallBaseExpression(defaultValue, ptr, methodWithArguments))\
{\
    return prefix_safeCallBaseExpression(defaultValue, ptr, methodWithArguments);\
}\
(objectPointer)
.fi
.SS "#define prefix_safeCallVoid(objectPointer, methodWithArguments)"
\fBValue:\fP
.PP
.nf
[&](auto&& ptr)\
{\
    if(ptr)\
        (ptr->methodWithArguments); \
}\
(objectPointer)
.fi
.SS "#define prefix_safeCallVoid(objectPointer, methodWithArguments)"
\fBValue:\fP
.PP
.nf
[&](decltype((objectPointer))&& ptr)\
{\
    if (ptr)\
        (ptr->methodWithArguments);\
}\
(objectPointer)
.fi
.SS "#define R   10"

.PP
A wrapper around static_assert for checking that a statement is noexcept and execution of that statement\&. Usage example: 
.PP
.nf
some_class::~some_class() noexcept {
    // We should have a guarantee that this call doesn't throw\&.
    NOEXCEPT_CTCHECK_ENSURE_NOEXCEPT_STATEMENT(m_some_resouce\&.release());
    \&.\&.\&.
}

.fi
.PP
.PP
A wrapper around static_assert for checking that a statement is not noexcept and execution of that statement\&.
.PP
Usage example: 
.PP
.nf
some_class::~some_class() noexcept {
    // If that call throws then we have to use try-catch block\&.
    try {
        NOEXCEPT_CTCHECK_ENSURE_NOT_NOEXCEPT_STATEMENT(m_some_resouce\&.release());
    }
    catch(\&.\&.\&.) {}
    \&.\&.\&.
}

.fi
.PP
.PP
A wrapper around static_assert for checking that an expression is noexcept
.PP
Usage example: 
.PP
.nf
void remove_appropriate_items_at_front(some_container_t & cnt) noexcept {
    NOEXCEPT_CTCHECK_STATIC_ASSERT_NOEXCEPT(cnt\&.empty());
    NOEXCEPT_CTCHECK_STATIC_ASSERT_NOEXCEPT(cnt\&.front());
    NOEXCEPT_CTCHECK_STATIC_ASSERT_NOEXCEPT(cnt\&.pop_front());

    while(!cnt\&.empty() && some_conditions(cnt\&.front()) {
        // We don't expect exceptions here\&.
        cnt\&.pop_front();
    }
}

.fi
.PP
.PP
A wrapper around static_assert for checking that an expression is not noexcept\&.
.PP
Usage example: 
.PP
.nf
void some_class::do_something() noexcept {
    // If the constructor of 'some_type' throws then we have to use try-catch block\&.
    NOEXCEPT_CTCHECK_STATIC_ASSERT_NOT_NOEXCEPT(
        some_type{
                std::declval<some_param_type>(),
                std::declval<another_param_type>()});
    try {
        some_type resource{first_arg, second_arg};
        \&.\&.\&.
    }
    catch(\&.\&.\&.) {}
    \&.\&.\&.
}

.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for MacrosLib from the source code\&.
